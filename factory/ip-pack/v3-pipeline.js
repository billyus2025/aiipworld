import fs from 'fs';
import path from 'path';
import { createNovel } from '../novel/generator/index.js';
import { createDrama } from '../drama/generator/index.js';
import { createComic } from '../comic/renderer/index.js';
import { createGame } from '../game/index.js';
import { translateJSON } from '../common/translation/translate.js';

const CONFIG = {
    outputPath: path.join(process.cwd(), 'data/ip')
};

export async function runV3Pipeline(ipId, context = {}) {
    console.log(`[V3] Starting Pipeline for ${ipId}...`);
    const ipDir = path.join(CONFIG.outputPath, ipId);
    if (!fs.existsSync(ipDir)) fs.mkdirSync(ipDir, { recursive: true });

    // 1. Meta
    const meta = {
        id: ipId,
        title: context.title || "Untitled IP",
        logline: context.idea || context.logline || "No logline",
        synopsis: context.synopsis || "No synopsis",
        genre: context.genre || "General",
        tags: context.tags || [],
        language: context.language || "en",
        createdAt: new Date().toISOString(),
        version: "3.0"
    };
    fs.writeFileSync(path.join(ipDir, 'meta.json'), JSON.stringify(meta, null, 2));

    // 2. Novel
    console.log(`[V3] Generating Novel...`);
    const novelResult = await createNovel(`${ipId}-novel`, context);
    // Consolidate novel data
    const novelData = {
        metadata: novelResult.metadata,
        outline: novelResult.outline,
        // In a real scenario we might not want ALL chapters in one file if they are huge, 
        // but for this "commercial landing page" purpose, having them accessible or at least a summary is good.
        // We will read the chapter files generated by createNovel and bundle them or just reference them.
        // For V3 requirement "High quality novel chapters (10-20)", let's bundle a preview.
        chapters: []
    };

    // Read generated chapters
    const novelDir = path.join(process.cwd(), 'data/novel', `${ipId}-novel`, 'chapters');
    if (fs.existsSync(novelDir)) {
        const files = fs.readdirSync(novelDir).sort((a, b) => {
            const numA = parseInt(a.match(/\d+/)?.[0] || 0);
            const numB = parseInt(b.match(/\d+/)?.[0] || 0);
            return numA - numB;
        });
        // Take first 5 for preview in JSON
        for (const f of files.slice(0, 5)) {
            const ch = JSON.parse(fs.readFileSync(path.join(novelDir, f), 'utf8'));
            novelData.chapters.push({
                id: ch.id,
                title: ch.title,
                excerpt: ch.content.substring(0, 200) + "..."
            });
        }
    }
    fs.writeFileSync(path.join(ipDir, 'novel.json'), JSON.stringify(novelData, null, 2));

    // 3. Drama
    console.log(`[V3] Generating Drama...`);
    const dramaResult = await createDrama(`${ipId}-drama`, {
        ...context,
        novelMetadata: novelResult.metadata,
        novelOutline: novelResult.outline
    });
    // Consolidate drama data
    const dramaData = {
        metadata: dramaResult.metadata,
        episodes: []
    };
    const dramaEpDir = path.join(process.cwd(), 'data/drama', `${ipId}-drama`, 'episodes');
    if (fs.existsSync(dramaEpDir)) {
        const files = fs.readdirSync(dramaEpDir);
        for (const f of files) {
            const ep = JSON.parse(fs.readFileSync(path.join(dramaEpDir, f), 'utf8'));
            dramaData.episodes.push(ep);
        }
    }
    fs.writeFileSync(path.join(ipDir, 'drama.json'), JSON.stringify(dramaData, null, 2));

    // 4. Comic
    console.log(`[V3] Generating Comic...`);
    const comicResult = await createComic(`${ipId}-comic`, {
        ...context,
        novelMetadata: novelResult.metadata
    });
    const comicData = {
        metadata: comicResult.metadata,
        thumbnails: [] // Mock thumbnails
    };
    // Mock thumbnails for V3
    for (let i = 1; i <= 5; i++) {
        comicData.thumbnails.push({ id: i, src: `https://via.placeholder.com/300x450?text=Comic+Panel+${i}` });
    }
    fs.writeFileSync(path.join(ipDir, 'comic.json'), JSON.stringify(comicData, null, 2));

    // 5. Game
    console.log(`[V3] Generating Game...`);
    // We usually generate multiple games (IF/VN). Let's pick one "Main" game for the landing page JSON.
    // Or store all.
    const gameData = {
        games: []
    };
    try {
        const vnGame = await createGame({ mode: 'vn', language: context.language, ipId });
        gameData.games.push(vnGame);
        // Also try IF
        const ifGame = await createGame({ mode: 'if', language: context.language, ipId });
        gameData.games.push(ifGame);
    } catch (e) {
        console.error("Game gen failed", e);
    }
    fs.writeFileSync(path.join(ipDir, 'game.json'), JSON.stringify(gameData, null, 2));

    console.log(`[V3] Pipeline Complete for ${ipId}. Data saved to ${ipDir}`);
}
